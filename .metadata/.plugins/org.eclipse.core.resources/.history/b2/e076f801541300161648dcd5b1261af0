//Домашнее задание №2

class Matrix {
	private int m, n;
	int arr[][];
	
	//Умолчательный конструктор класса
	private Matrix () {
		m=3;
		n=3;
		arr=new int [m][n];
		
		System.out.println("Текущая матрица:");
		//Заполнение матрицы произвольными числами
		for (int i=0; i<m; i++) {
			for (int j=0; j<n; j++) {
				
				arr[i][j]= (int) Math.round(Math.random()*100);
				System.out.print(arr[i][j]+ " ");
			}
			System.out.println();
		}
	}
	
	//Вспомогательный конструктор класса
	private Matrix (int m1, int n1) {
		m=m1;
		n=n1;
		
		arr=new int [m][];
		
		for (int i=0; i<m; i++) {
			arr[i]=new int [n];
		}
		
		System.out.println("Текущая матрица:");
		//Заполнение матрицы произвольными числами
		for (int i=0; i<m; i++) {
			for (int j=0; j<n; j++) {
				
				arr[i][j]= (int) Math.round(Math.random()*100);
				System.out.print(arr[i][j]+ " ");
			}
			System.out.println();
		}
	}
	
	//1. Сумма матриц
	public int[][] MatrixSum (int arr2[][]) {
		//Размерность текущей матрицы: m x n
		int [][] arr3 = new int [m][n];
		
		for (int i=0; i<m; i++) {
			for (int j=0; j<n; j++) {
				arr3[i][j]=arr[i][j] + arr2[i][j];
			}
		}
		
		return arr3;
	}
	
	//2. Разность матриц
	public int[][] MatrixDif (int arr2[][]) {
		//Размерность текущей матрицы: m x n
		int [][] arr3 = new int [m][n];
		
		for (int i=0; i<m; i++) {
			for (int j=0; j<n; j++) {
				arr3[i][j]=arr[i][j] - arr2[i][j];
			}
		}
		
		return arr3;
	}
	
	//3. Печать элементов матрицы в консоль
	public void MatrixPrint (int arr_prn[][]) {
		for (int i=0; i<arr_prn.length; i++){
			for (int j=0; j<arr_prn[i].length; j++){
				System.out.print(arr_prn[i][j]+ " ");
			}
			System.out.println();
		}
		System.out.println();
	}
	
	//4. Умножение текущей матрицы на число
	public int [][] MatrixNumMult (int mult){
		int [][] arr_out = new int [m][n];
		
		for (int i=0; i<m; i++) {
			for (int j=0; j<n; j++) {
				arr_out[i][j]=arr[i][j] * mult;
			}
		}
		return arr_out;
	}
	
	//5. Умножение матриц
	public int[][] MatrixMult (int[][] arr_in) {
		int [][] arr_out = new int [arr_in.length][arr[0].length];
		
		//Проверка на согласованность
		//Количество строк матрицы arr_in должно равняться количеству столбцов матрицы arr
		
		if (arr_in[0].length != arr.length) {
			System.out.println("Матрицы не согласованы");
			return null;
		}
		else
		{
			for (int i=0; i<m; i++) {
				for (int j=0; j<n; j++) {
					for (int k=0; k<m; k++){
						arr_out[i][j]+=arr_in[i][k] * arr[k][j];
					}
				}
			}
			return arr_out;
		}
	}
	
	//6. Вычисление определителя
    //рекурсивная функция - вычисляет значение определителя. Если на входе определитель 2х2 - просто вычисляем (крест-на-крест), иначе раскладываем на миноры. Для каждого минора вычисляем ЕГО определитель, рекурсивно вызывая ту же функцию..
    public int DetCalc(int[][] arr_in){
        int calcResult=0;
        if (arr_in.length==2){
            calcResult=arr_in[0][0]*arr_in[1][1]-arr_in[1][0]*arr_in[0][1];
        }
        else{
            int koeff=1;
            for(int i=0; i<arr_in.length; i++){
                if(i%2==1){  //Т.к. разложение идет всегда по первой (читай - "нулевой") строке, то фактически проверяется на четность значение i+0.
                    koeff=-1;
                }
                else{
                    koeff=1;
                };
      //собственно разложение:                
                calcResult += koeff*arr_in[0][i]*this.DetCalc(this.GetMinor(arr_in,0,i)); 
            }
        }
    //возвращаем ответ
        return calcResult;
    }
 
 
    //функция, к-я возвращает нужный нам минор. На входе - определитель, из к-го надо достать минор и номера строк-столбцов, к-е надо вычеркнуть.
    private int[][] GetMinor(int[][] arr_in, int row, int column){
        int minorLength = arr_in.length-1;
        int[][] minor = new int[minorLength][minorLength];
        int dI=0;//эти переменные для того, чтобы "пропускать" ненужные нам строку и столбец
        int dJ=0;
        for(int i=0; i<=minorLength; i++){
            dJ=0;
            for(int j=0; j<=minorLength; j++){
                if(i==row){
                    dI=1;
                }
                else{
                    if(j==column){
                        dJ=1;
                    }
                    else{
                        minor[i-dI][j-dJ] = arr_in[i][j];
                    }
                }
            }
        }
         
        return minor;
    }
     
    //7. Вычисление обратной матрицы
    public int[][] InverseMatrix(int[][] arr_in){
		int i,j,k;
		int size=arr_in[0].length;
		int[][] E = new int[size][size];//единичная матрица
		
		//заполнение единичной матрицы
		for (i=0;i<size;i++){
		    for (j=0;j<size;j++){    
		    	if (i==j) E[i][j]=1;
		    	else E[i][j]=0;
		    }
		}
		
		//Задаём номер ведущей строки (сначала 0,1...size)
		for (k=0;k<size;k++){    
    		for (j=k+1;j<size;j++){
    			arr_in[k][j]=arr_in[k][j]/arr_in[k][k];//все элементы k-ой строки матрицы A, кроме k-ого и до него, делим на разрешающий элемент - a[k][k]  
    		}
    		
    		for (j=0;j<size;j++){
    			E[k][j]=E[k][j]/arr_in[k][k];//все элементы k-ой строки матрицы e, делим на разрешающий элемент - a[k][k]    
    		}
    		
    		arr_in[k][k]=arr_in[k][k]/arr_in[k][k];//элемент соответствующий  разрещающему - делим на самого себя(т.е получит. 1 )
    		
    		//идём сверху вниз, обходя k-ую строку 
    		if (k>0) {//если номер ведущей строки не первый
    		    for (i=0;i<k;i++){   //строки, находящиеся выше k-ой
    		    	for (j=0;j<size;j++){
    		    		E[i][j]=E[i][j]-E[k][j]*arr_in[i][k];//Вычисляем элементы матрицы e,идя по столбцам с 0 -ого  к последнему  
    		    	}
    		    	for (j=size-1;j>=k;j--){
    		    		arr_in[i][j]=arr_in[i][j]-arr_in[k][j]*arr_in[i][k];//Вычисляем элементы матрицы a,идя по столбцам с последнего к k-ому
    		    	}
    		    }    
    		}
    		
    		for (i=k+1;i<size;i++){   //строки, находящиеся ниже k-ой 
    		    for (j=0;j<size;j++){    
    		    	E[i][j]=E[i][j]-E[k][j]*arr_in[i][k];
    		    }
    		    for (j=size-1;j>=k;j--){
    		    	arr_in[i][j]=arr_in[i][j]-arr_in[k][j]*arr_in[i][k];
    		    }
    		}
		}             
		return E;//На месте исходной матрицы должна получиться единичная а на месте единичной - обратная.    
	}
	
	
	
	
	
	
	
	
	
	
	public static void main(String[] args) {
		//Входящая матрица 4 х 4:
		int [][] arr_in = {{0, 1, 2, 3}, {8, 16, 10, 0}, {4, 34, 6, 2}, {1, 13, 25, 15}};
		int [][] arr_out = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}};

		//Инициализация класса
		Matrix M = new Matrix(4, 4);
		
		System.out.println("Входящая матрица:");
		M.MatrixPrint(arr_in);

		//Сумма матриц
		arr_out = M.MatrixSum(arr_in);
		System.out.println("Результирующая матрица (сумма):");
		M.MatrixPrint(arr_out);
		
		//Разность матриц
		arr_out = M.MatrixDif(arr_in);
		System.out.println("Результирующая матрица (разность):");
		M.MatrixPrint(arr_out);
		
		//Умножение матрицы на число
		arr_out = M.MatrixNumMult(14);
		System.out.println("Результирующая матрица (умножение на число 14):");
		M.MatrixPrint(arr_out);
		
		//Произведение матриц
		arr_out = M.MatrixMult(arr_in);
		System.out.println("Результирующая матрица (произведение):");
		M.MatrixPrint(arr_out);
		
		//Вычисление определителя
		int Result = M.DetCalc(arr_in);
		System.out.println("Определитель для входящей матрицы: "+Result);
		
		//Вычисление обратной матрицы
		arr_out = M.InverseMatrix(arr_in);
		System.out.println("Результирующая матрица (обратная):");
		M.MatrixPrint(arr_out);
		
		
		
	}
	
}
